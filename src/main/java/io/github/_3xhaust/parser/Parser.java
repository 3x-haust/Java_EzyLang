package io.github._3xhaust.parser;

import io.github._3xhaust.exception.ParseException;
import io.github._3xhaust.token.Token;

import java.math.BigDecimal;
import java.math.MathContext;
import java.util.*;

/**
 * This class is responsible for parsing a list of tokens into an Abstract Syntax Tree (AST).
 * It handles variable declarations, assignments, function calls, control flow statements, and expressions.
 * It also provides error handling by throwing ParseException if any syntax error occurs.
 */
public class Parser {

    // Set of valid data types in the language
    private static final Set<String> VALID_TYPES = new HashSet<>(Arrays.asList(
            Token.NUMBER, Token.CHAR, Token.STRING, Token.BOOLEAN,
            "number array", "char array", "string array", "boolean array", "null array",
            Token.ARRAY, Token.NULL
    ));

    // Set of valid return types for functions (including void)
    private static final Set<String> VALID_RETURN_TYPES = new HashSet<>(VALID_TYPES);

    static {
        VALID_RETURN_TYPES.add(Token.VOID);
    }

    /**
     * Represents a built-in function.
     */
    interface BuiltinFunction {
        /**
         * Executes the built-in function with the given context and arguments.
         *
         * @param context    The context of the function call, or null if not applicable.
         * @param arguments The list of arguments passed to the function.
         * @return The result of the function execution.
         * @throws ParseException If an error occurs during function execution.
         */
        Object execute(Object context, List<Object> arguments) throws ParseException;
    }

    /**
     * Represents a user-defined function.
     */
    private static class Function {
        String name; // Function name
        List<Parameter> parameters; // List of parameters
        String returnType; // Return type of the function
        int bodyStart; // Starting position of the function body in the token list
        int bodyEnd; // Ending position of the function body in the token list

        Function(String name, List<Parameter> parameters, String returnType, int bodyStart, int bodyEnd) {
            this.name = name;
            this.parameters = parameters;
            this.returnType = returnType;
            this.bodyStart = bodyStart;
            this.bodyEnd = bodyEnd;
        }
    }

    /**
     * Represents a function parameter.
     */
    private static class Parameter {
        String name; // Parameter name
        String type; // Parameter type

        Parameter(String name, String type) {
            this.name = name;
            this.type = type;
        }
    }

    private final List<Token> tokens; // List of tokens generated by the lexer
    private final String fileName; // Name of the file being parsed
    private final String[] lines; // Lines of the input code for error reporting
    private int position = 0; // Current position in the token list

    // Stack of scopes for variable resolution
    private final Deque<Map<String, Object>> scopes = new LinkedList<>();
    // Map to store variable types
    private final Map<String, String> variableTypes = new HashMap<>();
    // Map to store user-defined functions
    private final Map<String, Function> functions = new HashMap<>();
    // Set to store constant variable names
    private final Set<String> constants = new HashSet<>();
    // Map to store built-in functions for different context types
    private final Map<String, Map<Class<?>, BuiltinFunction>> builtinFunctions = new HashMap<>();

    /**
     * Constructor for the Parser class.
     *
     * @param tokens   The list of tokens to be parsed.
     * @param fileName The name of the file being parsed.
     * @param input   The input code as a single string.
     * @throws ParseException If there's an error during initialization.
     */
    public Parser(List<Token> tokens, String fileName, String input) throws ParseException {
        this.fileName = fileName;
        this.lines = input.split("\n");
        this.tokens = tokens;
        tokens.forEach(token -> System.out.println(token.getToken()));
        // Initialize the global scope
        scopes.push(new HashMap<>());
        // Register built-in functions
        initializeBuiltinFunctions();
        // Pre-parse function declarations for later calls
        preParseFunctions();

    }

    /**
     * Pre-parses function declarations to allow function calls before their definitions.
     *
     * @throws ParseException If an error occurs during function declaration parsing.
     */
    private void preParseFunctions() throws ParseException {
        int savedPosition = position;
        while (!isAtEnd()) {
            if (currentPosition().getToken().equals(Token.FUNC)) {
                functionDeclaration();
            } else {
                position++;
            }
        }
        position = savedPosition;
    }

    /**
     * Initializes the map of built-in functions.
     */
    private void initializeBuiltinFunctions() {
        // Register the 'length' function for ArrayLists
        registerBuiltinFunction("length", ArrayList.class, (context, args) ->
                new BigDecimal(((List<?>) context).size()));

        // Register the 'repeat' function for Strings
        registerBuiltinFunction("repeat", String.class, (context, args) -> {
            validateArguments("repeat", args, 1, BigDecimal.class);
            int count = ((BigDecimal) args.get(0)).intValue();
            return ((String) context).repeat(count);
        });

        // Register the 'add' function for ArrayLists
        registerBuiltinFunction("add", ArrayList.class, (context, args) -> {
            validateArguments("add", args, 2, List.class, Object.class);
            ((List<Object>) args.get(0)).add(args.get(1));
            return null;
        });

        // Register the 'get' function for Lists
        registerBuiltinFunction("get", List.class, (context, args) -> {
            validateArguments("get", args, 2, List.class, BigDecimal.class);
            List<Object> list = (List<Object>) args.get(0);
            int index = ((BigDecimal) args.get(1)).intValue();
            if (index < 0 || index >= list.size())
                throw new ParseException(fileName, "Index out of bounds",
                        currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
            return list.get(index);
        });

        // Register the 'set' function for ArrayLists
        registerBuiltinFunction("set", ArrayList.class, (context, args) -> {
            validateArguments("set", args, 3, List.class, BigDecimal.class, BigDecimal.class);
            List<Object> list = (List<Object>) args.get(0);
            int index = ((BigDecimal) args.get(1)).intValue();
            if (index < 0 || index >= list.size())
                throw new ParseException(fileName, "Index out of bounds",
                        currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
            list.set(index, args.get(2));
            return null;
        });

        // Register the 'remove' function for ArrayLists
        registerBuiltinFunction("remove", ArrayList.class, (context, args) -> {
            validateArguments("remove", args, 2, List.class, BigDecimal.class);
            List<Object> list = (List<Object>) args.get(0);
            int index = ((BigDecimal) args.get(1)).intValue();
            if (index < 0 || index >= list.size())
                throw new ParseException(fileName, "Index out of bounds",
                        currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
            return list.remove(index);
        });
    }

    /**
     * Validates the arguments passed to a built-in function.
     *
     * @param functionName    The name of the function being called.
     * @param args           The list of arguments passed to the function.
     * @param expectedCount  The expected number of arguments.
     * @param expectedTypes The expected types of arguments.
     * @throws ParseException If the arguments are invalid.
     */
    private void validateArguments(String functionName, List<Object> args, int expectedCount, Class<?>... expectedTypes) throws ParseException {
        if (args.size() != expectedCount) {
            throw new ParseException(fileName, functionName + "() expects " + (expectedCount - 1)+
                    " argument" + (expectedCount > 1 ? "s" : "") + ", but got " + (args.size() - 1),
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }
        for (int i = 0; i < expectedCount; i++) {
            if (!(expectedTypes[i].isInstance(args.get(i)))) {
                throw new ParseException(fileName, functionName + "() argument " + (i + 1) +
                        " should be " + expectedTypes[i].getSimpleName() + ", but got " +
                        args.get(i).getClass().getSimpleName(),
                        currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
            }
        }
    }

    /**
     * Parses the list of tokens and executes statements.
     */
    public void parse() {
        try {
            while (!isAtEnd()) {
                statement();
            }
        } catch (ParseException e) {
            System.err.println(e.getFormattedMessage());
        }
    }

    /**
     * Parses a single statement.
     *
     * @throws ParseException If a syntax error is encountered.
     */
    private void statement() throws ParseException {
        // Determine the type of statement based on the current token
        switch (currentPosition().getToken()) {
            case Token.PRINT, Token.PRINTLN -> printStatement();
            case Token.FOR -> forStatement();
            case Token.IF -> ifStatement();
            case Token.FUNC -> functionDeclaration();
            case Token.IDENTIFIER, Token.DOLLAR -> {
                switch (peek(1).getToken()) {
                    // Handle method calls with '.'
                    case Token.DOT -> dotStatement();
                    // Handle function calls with '('
                    case Token.LEFT_PAREN -> functionCall(consume(Token.IDENTIFIER).getValue());
                    // Handle variable assignments with '=' or array assignments with '['
                    case Token.EQUAL, Token.LEFT_BRACKET -> variableAssignment();
                    // Handle variable declarations
                    default -> variableDeclaration();
                }
            }
            default -> throw unexpectedTokenException("Invalid start of statement");

        }
    }

    /**
     * Parses and handles method calls using the '.' operator.
     *
     * @throws ParseException If an error occurs during method call parsing.
     */
    private void dotStatement() throws ParseException {
        String identifier = consume(Token.IDENTIFIER).getValue();
        consume(Token.DOT);
        String methodName = consume(Token.IDENTIFIER).getValue();
        Object object = getVariableValue(identifier);

        List<Object> args = new ArrayList<>();
        args.add(object);
        if (currentPosition().getToken().equals(Token.LEFT_PAREN)) {
            args.addAll(parseArguments());
        }

        handleMethodCall(object, methodName, args);
    }

    /**
     * Parses a function declaration and stores it in the 'functions' map.
     *
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void functionDeclaration() throws ParseException {
        consume(Token.FUNC);
        String functionName = consume(Token.IDENTIFIER).getValue();
        consume(Token.LEFT_PAREN);

        List<Parameter> parameters = new ArrayList<>();
        while (!currentPosition().getToken().equals(Token.RIGHT_PAREN)) {
            String paramName = consume(Token.IDENTIFIER).getValue();
            consume(Token.COLON);
            String paramType = consume(currentPosition().getToken()).getToken();

            validateType(paramType);

            parameters.add(new Parameter(paramName, paramType));

            if (currentPosition().getToken().equals(Token.COMMA)) {
                consume(Token.COMMA);
            }
        }
        consume(Token.RIGHT_PAREN);

        String returnType = peek(1).getToken();
        if (currentPosition().getToken().equals(Token.COLON)) {
            consume(Token.COLON);
            returnType = consume(currentPosition().getToken()).getValue();
            validateReturnType(returnType);
        }

        consume(Token.LEFT_BRACE);
        int functionBodyStart = position;

        int braceCount = 1;
        while (braceCount > 0 && !isAtEnd()) {
            if (currentPosition().getToken().equals(Token.RIGHT_BRACE)) {
                braceCount--;
            }
            position++;
        }

        if (braceCount > 0) {
            throw new ParseException(fileName, "Unclosed function body",
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }

        int functionBodyEnd = position - 1;

        functions.put(functionName, new Function(functionName, parameters, returnType, functionBodyStart, functionBodyEnd));
    }

    /**
     * Parses and executes a function call.
     *
     * @param functionName The name of the function to call.
     * @return The return value of the function, or null if it doesn't return a value.
     * @throws ParseException If an error occurs during function call parsing or execution.
     */
    private Object functionCall(String functionName) throws ParseException {
        consume(Token.LEFT_PAREN);
        List<Object> arguments = new ArrayList<>();
        if (!currentPosition().getToken().equals(Token.RIGHT_PAREN)) {
            do {
                arguments.add(expression());
                if (currentPosition().getToken().equals(Token.COMMA)) {
                    consume(Token.COMMA);
                } else break;
            } while (true);
        }

        consume(Token.RIGHT_PAREN);

        // Check if it's a user-defined function
        if (functions.containsKey(functionName)) {
            return executeUserDefinedFunction(functionName, arguments);
        }
        // Check if it's a built-in function
        else if (builtinFunctions.containsKey(functionName)) {
            return handleMethodCall(null, functionName, arguments);
        }
        // Function not found
        else {
            throw new ParseException(fileName, "Undefined function: " + functionName,
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }
    }

    /**
     * Executes a user-defined function.
     *
     * @param functionName The name of the function to execute.
     * @param arguments   The list of arguments passed to the function.
     * @return The return value of the function, or null if it doesn't return a value.
     * @throws ParseException If an error occurs during function execution.
     */
    private Object executeUserDefinedFunction(String functionName, List<Object> arguments) throws ParseException {
        Function function = functions.get(functionName);
        if (arguments.size() != function.parameters.size()) {
            throw new ParseException(fileName,
                    "Function " + functionName + " expects " + function.parameters.size() +
                            " arguments, but got " + arguments.size(),
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }

        // Create a new scope for the function
        enterScope();
        for (int i = 0; i < function.parameters.size(); i++) {
            Parameter param = function.parameters.get(i);
            getCurrentScope().put(param.name, arguments.get(i));
        }

        // Execute the function body
        int savedPosition = position;
        position = function.bodyStart;

        Object returnValue = null;
        boolean returned = false;

        while (position < function.bodyEnd) {
            if (currentPosition().getToken().equals(Token.RETURN)) {
                consume(Token.RETURN);

                // Check if a void function is trying to return a value
                if (function.returnType.equals(Token.VOID)) {
                    throw new ParseException(fileName, "Void function should not return a value",
                            currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
                }

                returnValue = expression();
                returned = true;

                // Type check the returned value
                checkType(returnValue, function.returnType);

                break;
            }
            statement();
        }

        // Check for missing return statement in non-void functions
        if (!function.returnType.equals(Token.VOID) && !returned) {
            throw new ParseException(fileName, "Missing return statement in function '" + function.name + "'",
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }

        exitScope();
        position = savedPosition;

        return returnValue;
    }


    /**
     * Parses the arguments passed to a function call.
     *
     * @return A list of parsed argument values.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private List<Object> parseArguments() throws ParseException {
        consume(Token.LEFT_PAREN);
        List<Object> arguments = new ArrayList<>();
        if (!currentPosition().getToken().equals(Token.RIGHT_PAREN)) {
            do {
                arguments.add(expression());
                if (currentPosition().getToken().equals(Token.COMMA)) {
                    consume(Token.COMMA);
                } else break;
            } while (true);
        }
        consume(Token.RIGHT_PAREN);
        return arguments;
    }

    /**
     * Parses a variable declaration statement.
     *
     * @throws ParseException If a syntax error is encountered or if the variable is already declared in the current scope.
     */
    private void variableDeclaration() throws ParseException {
        boolean isConstant = currentPosition().getToken().equals(Token.DOLLAR);
        if (isConstant) consume(Token.DOLLAR);

        String variableName = consume(Token.IDENTIFIER).getValue();
        ensureVariableNotDeclaredLocal(variableName);

        consume(Token.COLON);
        String type = parseType();

        consume(Token.EQUAL);

        if (type.endsWith("array")) {
            declareArrayVariable(variableName, type, isConstant);
        } else {
            declareVariable(variableName, type, isConstant);
        }

        variableTypes.put(variableName, type);
    }

    /**
     * Parses the type of a variable, including array dimensions.
     *
     * @return The parsed type string.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private String parseType() throws ParseException {
        String baseType = consume(currentPosition().getToken()).getToken();
        StringBuilder fullType = new StringBuilder(baseType);

        while (currentPosition().getToken().equals(Token.LEFT_BRACKET)) {
            consume(Token.LEFT_BRACKET);
            consume(Token.RIGHT_BRACKET);
            fullType.append(" array");
        }

        return fullType.toString();
    }

    /**
     * Declares a variable with the specified name, type, and initial value.
     *
     * @param variableName  The name of the variable to declare.
     * @param type         The type of the variable.
     * @param isConstant  Indicates if the variable is a constant.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void declareVariable(String variableName, String type, boolean isConstant) throws ParseException {
        Object value = getTypedValue(type);

        if (isConstant) constants.add(variableName);

        getCurrentScope().put(variableName, value);
    }

    /**
     * Declares an array variable with the specified name, type, and initial values.
     *
     * @param variableName  The name of the array variable to declare.
     * @param type         The type of the array.
     * @param isConstant  Indicates if the variable is a constant.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void declareArrayVariable(String variableName, String type, boolean isConstant) throws ParseException {
        consume(Token.LEFT_BRACKET);

        List<Object> array = parseMultiDimensionalArray(type);

        consume(Token.RIGHT_BRACKET);

        if (isConstant) {
            constants.add(variableName);
        }
        getCurrentScope().put(variableName, array);
    }

    /**
     * Parses a multi-dimensional array declaration.
     *
     * @param type The type of the array.
     * @return A List representing the parsed multi-dimensional array.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private List<Object> parseMultiDimensionalArray(String type) throws ParseException {
        List<Object> array = new ArrayList<>();
        while (!currentPosition().getToken().equals(Token.RIGHT_BRACKET)) {
            if (currentPosition().getToken().equals(Token.LEFT_BRACKET)) {
                consume(Token.LEFT_BRACKET);
                array.add(parseMultiDimensionalArray(type.replace(" array", "")));
                consume(Token.RIGHT_BRACKET);
            } else {
                array.add(parseArrayElement(type.replace(" array", "")));
            }
            if (currentPosition().getToken().equals(Token.COMMA)) {
                consume(Token.COMMA);
            }
        }
        return array;
    }

    /**
     * Parses a single array element based on the array type.
     *
     * @param arrayType The type of the array.
     * @return The parsed array element.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private Object parseArrayElement(String arrayType) throws ParseException {
        String elementType = arrayType.replace(" array", "");
        return getTypedValue(elementType);
    }

    /**
     * Ensures that a variable with the given name is not already declared in the current scope.
     *
     * @param variableName The name of the variable to check.
     * @throws ParseException If the variable is already declared in the current scope.
     */
    private void ensureVariableNotDeclaredLocal(String variableName) throws ParseException {
        if (getCurrentScope().containsKey(variableName)) {
            throw new ParseException(fileName, "Variable '" + variableName + "' already declared in this scope",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }
    }

    /**
     * Gets a typed value based on the provided type string.
     *
     * @param type The expected type of the value.
     * @return The parsed value.
     * @throws ParseException If a parsing error occurs or the type is not supported.
     */
    private Object getTypedValue(String type) throws ParseException {
        String currentTokenType = currentPosition().getToken();

        if (currentTokenType.equals(getTokenLiteralByType(type))) {
            return switch (type) {
                case Token.NUMBER -> expressionNumber();
                case Token.STRING -> expressionString();
                case Token.BOOLEAN -> expressionBoolean();
                case Token.CHAR -> expressionChar();
                case Token.NULL -> expressionNull();
                default -> throw new ParseException(fileName, "Unsupported type: " + type.toLowerCase(),
                        currentPosition().getLine(),
                        currentPosition().getColumn(),
                        getCurrentLine());
            };
        } else {
            Object result = expression();

            if ((type.equals(Token.NUMBER) && !(result instanceof BigDecimal)) ||
                    (type.equals(Token.STRING) && !(result instanceof String)) ||
                    (type.equals(Token.BOOLEAN) && !(result instanceof Boolean)) ||
                    (type.equals(Token.CHAR) && !(result instanceof Character)) ||
                    (type.equals(Token.NULL) && result != null)) {
                throw new ParseException(fileName, "Type mismatch: Expected " + type.toLowerCase() + ", found " + result.getClass().getSimpleName(),
                        currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
            }

            return result;
        }
    }

    /**
     * Gets the corresponding token literal for a given type.
     *
     * @param type The type to get the literal for.
     * @return The token literal string.
     */
    private String getTokenLiteralByType(String type) {
        return switch (type) {
            case Token.NUMBER -> Token.NUMBER_LITERAL;
            case Token.STRING -> Token.STRING_LITERAL;
            case Token.BOOLEAN -> Token.BOOLEAN_LITERAL;
            case Token.CHAR -> Token.CHAR_LITERAL;
            case Token.NULL -> Token.NULL;
            default -> "";
        };
    }

    /**
     * Parses a variable assignment statement.
     *
     * @throws ParseException If a syntax error is encountered or if the variable is not declared or is a constant.
     */
    private void variableAssignment() throws ParseException {
        if (currentPosition().getToken().equals(Token.IDENTIFIER) &&
                peek(1).getToken().equals(Token.LEFT_BRACKET)) {
            assignToArrayElement();
        } else {
            assignToVariable();
        }
    }

    /**
     * Parses and handles array element assignment.
     *
     * @throws ParseException If a syntax error is encountered or if the array index is out of bounds.
     */
    private void assignToArrayElement() throws ParseException {
        String arrayName = consume(Token.IDENTIFIER).getValue();
        List<Integer> indices = new ArrayList<>();

        while (currentPosition().getToken().equals(Token.LEFT_BRACKET)) {
            consume(Token.LEFT_BRACKET);
            indices.add(((BigDecimal) expression()).intValue());
            consume(Token.RIGHT_BRACKET);
        }

        consume(Token.EQUAL);

        Object value = expression();
        assignValueAtIndices(arrayName, indices, value);
    }

    /**
     * Assigns a value to an array element at the specified indices.
     *
     * @param arrayName The name of the array variable.
     * @param indices   The list of indices to access the array element.
     * @param value     The value to assign.
     * @throws ParseException If a syntax error is encountered or if the array index is out of bounds.
     */
    private void assignValueAtIndices(String arrayName, List<Integer> indices, Object value) throws ParseException {
        Object array = getVariableValue(arrayName);
        setValueAtIndices(array, indices, 0, value);
    }

    /**
     * Recursively sets a value at the specified indices of a multi-dimensional array.
     *
     * @param array  The current level of the array (or sub-array).
     * @param indices The list of indices to access the array element.
     * @param depth   The current depth of recursion in the multi-dimensional array.
     * @param value   The value to assign.
     * @throws ParseException If a syntax error is encountered or if the array index is out of bounds.
     */
    private void setValueAtIndices(Object array, List<Integer> indices, int depth, Object value) throws ParseException {
        if (!(array instanceof List)) {
            throw new ParseException(fileName, "Trying to access non-array element as array",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }

        List<Object> list = (List<Object>) array;
        int index = indices.get(depth);

        if (index < 0 || index >= list.size()) {
            throw new ParseException(fileName, "Array index out of bounds: " + index,
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }

        if (depth == indices.size() - 1) {
            list.set(index, value);
        } else {
            setValueAtIndices(list.get(index), indices, depth + 1, value);
        }
    }

    /**
     * Parses and handles variable assignments.
     *
     * @throws ParseException If a syntax error is encountered or if the variable is not declared or is a constant.
     */
    private void assignToVariable() throws ParseException {
        String variableName = consume(Token.IDENTIFIER).getValue();

        consume(Token.EQUAL);

        if (isConstantDeclared(variableName)) {
            throw new ParseException(fileName, "Cannot reassign constant variable: " + variableName,
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }

        Object value = expression();
        if (!assignVariableIfDeclared(variableName, value)) {
            throw new ParseException(fileName, "Undefined variable: " + variableName,
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }
    }

    /**
     * Assigns a value to an array element at the specified index.
     *
     * @param arrayName The name of the array variable.
     * @param index    The index of the element to assign.
     * @param value     The value to assign.
     * @throws ParseException If the array index is out of bounds or if a type mismatch occurs.
     */
    private void assignValueAtIndex(String arrayName, int index, Object value) throws ParseException {
        Object array = getVariableValue(arrayName);

        if (array instanceof List<?> arrayList) {
            if (index < 0 || index >= arrayList.size()) {
                throw new ParseException(fileName, "Array index out of bounds: " + index,
                        currentPosition().getLine(),
                        currentPosition().getColumn(),
                        getCurrentLine());
            }

            String arrayType = getVariableType(arrayName).replace(" array", "");
            if (!checkElementType(arrayType, value)) {
                throw new ParseException(fileName,
                        "Type mismatch: Cannot assign " + value.getClass().getSimpleName() + " to " + arrayType,
                        currentPosition().getLine(),
                        currentPosition().getColumn(),
                        getCurrentLine());
            }

            ((List) arrayList).set(index, value);
        } else {
            throw new ParseException(fileName, "Variable '" + arrayName + "' is not an array",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }
    }

    /**
     * Checks if the provided element is of the correct type for the given array type.
     *
     * @param arrayType   The type of the array.
     * @param element  The element to check.
     * @return True if the element type matches the array type, otherwise false.
     */
    private boolean checkElementType(String arrayType, Object element) {
        String elementType = arrayType.replace(" array", "");
        return switch (elementType) {
            case Token.NUMBER -> element instanceof BigDecimal;
            case Token.STRING -> element instanceof String;
            case Token.BOOLEAN -> element instanceof Boolean;
            case Token.CHAR -> element instanceof Character;
            case Token.NULL -> element == null;
            default -> false;
        };
    }

    /**
     * Gets the type of a declared variable.
     *
     * @param variableName The name of the variable.
     * @return The type of the variable.
     * @throws ParseException If the variable is not declared.
     */
    private String getVariableType(String variableName) throws ParseException {
        if (!isVariableDeclared(variableName)) {
            throw new ParseException(fileName, "Undefined variable: " + variableName,
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }

        return variableTypes.get(variableName);
    }

    /**
     * Parses a for loop statement.
     *
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void forStatement() throws ParseException {
        consume(Token.FOR);
        consume(Token.LEFT_PAREN);

        String variable = consume(Token.IDENTIFIER).getValue();
        consume(Token.COLON);
        String type = consume(currentPosition().getToken()).getToken();
        consume(Token.IN);

        // Determine if iterating over an array or a range
        if (currentPosition().getToken().equals(Token.IDENTIFIER)) {
            iterateOverArray(variable, type);
        } else if (currentPosition().getToken().equals(Token.NUMBER_LITERAL) ||
                currentPosition().getToken().equals(Token.DOT_LENGTH)) {
            iterateOverRange(variable, type);
        } else {
            throw unexpectedTokenException("Expected identifier or number literal after 'in'");
        }
    }

    /**
     * Iterates over an array in a for loop.
     *
     * @param variable       The name of the loop variable.
     * @param type          The type of the loop variable.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void iterateOverArray(String variable, String type) throws ParseException {
        String arrayVariable = consume(Token.IDENTIFIER).getValue();
        consume(Token.RIGHT_PAREN);

        Object arrayObject = getVariableValue(arrayVariable);
        if (!(arrayObject instanceof List<?> array)) {
            throw new ParseException(fileName, "Variable '" + arrayVariable + "' is not an array",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }

        enterScope();

        int forLoopStartPosition = position;
        for (Object element : array) {
            position = forLoopStartPosition;

            getCurrentScope().put(variable, element);
            executeForLoopBody();
        }

        exitScope();
    }

    /**
     * Iterates over a range of values in a for loop.
     *
     * @param variable The name of the loop variable.
     * @param type    The type of the loop variable.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void iterateOverRange(String variable, String type) throws ParseException {
        BigDecimal start = getRangeStart();
        consume(Token.DOT_DOT);
        BigDecimal end = expressionNumber();
        BigDecimal step = BigDecimal.ONE;

        if (currentPosition().getToken().equals(Token.DOT_DOT)) {
            consume(Token.DOT_DOT);
            step = expressionNumber();
        }
        consume(Token.RIGHT_PAREN);

        if (step.compareTo(BigDecimal.ZERO) == 0) {
            throw new ParseException(fileName, "Step cannot be zero",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }

        enterScope();

        int forLoopStartPosition = position;
        if (step.compareTo(BigDecimal.ZERO) > 0) {
            for (BigDecimal i = start; i.compareTo(end) <= 0; i = i.add(step)) {
                position = forLoopStartPosition;
                checkType(i, type);
                getCurrentScope().put(variable, i);
                executeForLoopBody();
            }
        } else {
            for (BigDecimal i = start; i.compareTo(end) >= 0; i = i.add(step)) {
                position = forLoopStartPosition;
                checkType(i, type);
                getCurrentScope().put(variable, i);
                executeForLoopBody();
            }
        }

        exitScope();
    }

    /**
     * Gets the start value for a for loop range.
     *
     * @return The start value as a BigDecimal.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private BigDecimal getRangeStart() throws ParseException {
        if (currentPosition().getToken().equals(Token.DOT_LENGTH)) {
            consume(Token.DOT_LENGTH);
            String arrayVariable = consume(Token.IDENTIFIER).getValue();

            Object arrayObject = getVariableValue(arrayVariable);
            if (!(arrayObject instanceof List)) {
                throw new ParseException(fileName, "Variable '" + arrayVariable + "' is not an array",
                        currentPosition().getLine(),
                        currentPosition().getColumn(),
                        getCurrentLine());
            }

            return new BigDecimal(((List<?>) arrayObject).size());
        } else {
            return expressionNumber();
        }
    }

    /**
     * Checks if the provided value matches the expected type.
     *
     * @param value The value to check.
     * @param type  The expected type.
     * @throws ParseException If the value's type does not match the expected type.
     */
    private void checkType(Object value, String type) throws ParseException {
        if (type.endsWith(" array")) {
            if (!(value instanceof List<?>)) {
                throw new ParseException(fileName, "Type mismatch: Expected " + type + ", found " + value.getClass().getSimpleName(),
                        currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
            }

            String elementType = type.substring(0, type.length() - " array".length());
            for (Object element : (List<?>) value) {
                checkType(element, elementType);
            }
        } else {
            boolean isValidType = switch (type) {
                case Token.NUMBER -> value instanceof BigDecimal;
                case Token.STRING -> value instanceof String;
                case Token.BOOLEAN -> value instanceof Boolean;
                case Token.CHAR -> value instanceof Character;
                case Token.NULL -> value == null;
                default -> false;
            };

            if (!isValidType) {
                throw new ParseException(fileName, "Type mismatch: Expected " + type + ", found " + value.getClass().getSimpleName(),
                        currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
            }
        }
    }

    /**
     * Executes the body of a for loop.
     *
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void executeForLoopBody() throws ParseException {
        if (currentPosition().getToken().equals(Token.LEFT_BRACE)) {
            consume(Token.LEFT_BRACE);
            block();
            consume(Token.RIGHT_BRACE);
        } else {
            statement();
        }
    }

    /**
     * Parses and executes a print statement (either 'print' or 'println').
     *
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void printStatement() throws ParseException {
        boolean ln = currentPosition().getToken().equals(Token.PRINTLN);
        consume(ln ? Token.PRINTLN : Token.PRINT);

        consume(Token.LEFT_PAREN);

        List<Object> printArgs = new ArrayList<>();
        while (!currentPosition().getToken().equals(Token.RIGHT_PAREN)) {
            printArgs.add(expression());
            if (currentPosition().getToken().equals(Token.COMMA)) {
                consume(Token.COMMA);
            }
        }

        consume(Token.RIGHT_PAREN);

        for (Object arg : printArgs) {
            String output = (arg instanceof String) ? (String) arg : String.valueOf(arg);
            System.out.print(output);
        }

        if (ln) {
            System.out.println();
        }
    }

    /**
     * Parses and executes an if statement, including else if and else blocks.
     *
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void ifStatement() throws ParseException {
        consume(Token.IF);
        consume(Token.LEFT_PAREN);
        boolean condition = evaluateCondition();
        consume(Token.RIGHT_PAREN);

        if (condition) {
            enterScope();
            executeConditionalBlock();
            exitScope();
        } else {
            skipConditionalBlock();
        }

        handleElseIf(condition);
        handleElse(condition);
    }

    /**
     * Handles else if blocks in an if statement.
     *
     * @param previousConditionMet Indicates if any previous condition in the if-else if chain has been met.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void handleElseIf(boolean previousConditionMet) throws ParseException {
        while (currentPosition().getToken().equals(Token.ELSE_IF)) {
            consume(Token.ELSE_IF);
            consume(Token.LEFT_PAREN);
            boolean condition = evaluateCondition();
            consume(Token.RIGHT_PAREN);

            if (!previousConditionMet && condition) {
                enterScope();
                executeConditionalBlock();
                exitScope();
                previousConditionMet = true;
            } else {
                skipConditionalBlock();
            }
        }
    }

    /**
     * Handles the else block in an if statement.
     *
     * @param previousConditionMet Indicates if any previous condition in the if-else if chain has been met.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void handleElse(boolean previousConditionMet) throws ParseException {
        if (currentPosition().getToken().equals(Token.ELSE)) {
            consume(Token.ELSE);

            if (!previousConditionMet) {
                enterScope();
                executeConditionalBlock();
                exitScope();
            } else {
                skipConditionalBlock();
            }
        }
    }


    /**
     * Evaluates the condition of an if statement or else if statement.
     *
     * @return True if the condition evaluates to true, otherwise false.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private boolean evaluateCondition() throws ParseException {
        if (currentPosition().getToken().equals(Token.BOOLEAN_LITERAL)) {
            return Boolean.parseBoolean(consume(Token.BOOLEAN_LITERAL).getValue());
        } else {
            return evaluateExpression();
        }
    }

    /**
     * Executes the code block within an if, else if, or else block.
     *
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void executeConditionalBlock() throws ParseException {
        if (currentPosition().getToken().equals(Token.LEFT_BRACE)) {
            consume(Token.LEFT_BRACE);
            block();
            consume(Token.RIGHT_BRACE);
        } else {
            statement();
        }
    }

    /**
     * Skips over the code block within an if, else if, or else block if the condition is not met.
     */
    private void skipConditionalBlock() {
        if (currentPosition().getToken().equals(Token.LEFT_BRACE)) {
            int braceCount = 1;
            position++;
            while (braceCount > 0 && !isAtEnd()) {
                if (currentPosition().getToken().equals(Token.LEFT_BRACE)) {
                    braceCount++;
                } else if (currentPosition().getToken().equals(Token.RIGHT_BRACE)) {
                    braceCount--;
                }
                position++;
            }
        } else {
            skipStatement();
        }
    }

    /**
     * Skips over a single statement.
     */
    private void skipStatement() {
        while (!isAtEnd()) {
            position++;
        }
        if (!isAtEnd()) {
            position++;
        }
    }

    /**
     * Parses and executes a block of code enclosed in curly braces.
     *
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private void block() throws ParseException {
        enterScope();
        while (!currentPosition().getToken().equals(Token.RIGHT_BRACE) && !isAtEnd()) {
            statement();
        }
        exitScope();
    }

    /**
     * Enters a new scope for variable resolution.
     */
    private void enterScope() {
        scopes.push(new HashMap<>());
    }

    /**
     * Exits the current scope and returns to the previous one.
     */
    private void exitScope() {
        scopes.pop();
    }

    /**
     * Checks if the parser has reached the end of the token list.
     *
     * @return True if the end of the token list has been reached, otherwise false.
     */
    private boolean isAtEnd() {
        return position >= tokens.size() || currentPosition().getToken().equals(Token.EOF);
    }

    /**
     * Parses a number literal expression.
     *
     * @return The parsed number as a BigDecimal.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private BigDecimal expressionNumber() throws ParseException {
        return logicalOrExpression();
    }

    /**
     * Parses a string literal expression.
     *
     * @return The parsed string.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private String expressionString() throws ParseException {
        return consume(Token.STRING_LITERAL).getValue();
    }

    /**
     * Parses a boolean literal expression.
     *
     * @return The parsed boolean value.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private Boolean expressionBoolean() throws ParseException {
        return Boolean.parseBoolean(consume(Token.BOOLEAN_LITERAL).getValue());
    }

    /**
     * Parses a char literal expression.
     *
     * @return The parsed char value.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private Character expressionChar() throws ParseException {
        String charValue = consume(Token.CHAR_LITERAL).getValue();
        if (charValue.length() != 1) {
            throw new ParseException(fileName, "Invalid char literal: " + charValue,
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }
        return charValue.charAt(0);
    }

    /**
     * Parses a null literal expression.
     *
     * @return Null.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private Object expressionNull() throws ParseException {
        if (!currentPosition().getToken().equals(Token.NULL)) {
            throw unexpectedTokenException("Type mismatch: Expected null");
        }

        consume(Token.NULL);
        return null;
    }

    /**
     * Parses a logical OR expression.
     *
     * @return The result of the logical OR operation as a BigDecimal (1 for true, 0 for false).
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private BigDecimal logicalOrExpression() throws ParseException {
        BigDecimal left = logicalAndExpression();
        while (currentPosition().getToken().equals(Token.OR)) {
            position++;
            BigDecimal right = logicalAndExpression();
            left = (left.compareTo(BigDecimal.ZERO) != 0 || right.compareTo(BigDecimal.ZERO) != 0) ? BigDecimal.ONE : BigDecimal.ZERO;
        }
        return left;
    }

    /**
     * Parses a logical AND expression.
     *
     * @return The result of the logical AND operation as a BigDecimal (1 for true, 0 for false).
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private BigDecimal logicalAndExpression() throws ParseException {
        BigDecimal left = equalityExpression();
        while (currentPosition().getToken().equals(Token.AND)) {
            position++;
            BigDecimal right = equalityExpression();
            left = (left.compareTo(BigDecimal.ZERO) != 0 && right.compareTo(BigDecimal.ZERO) != 0) ? BigDecimal.ONE : BigDecimal.ZERO;
        }
        return left;
    }

    /**
     * Parses an equality expression (== or !=).
     *
     * @return The result of the equality comparison as a BigDecimal (1 for true, 0 for false).
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private BigDecimal equalityExpression() throws ParseException {
        BigDecimal left = (BigDecimal) arithmeticExpression();
        if (isComparisonOperator(currentPosition().getToken())) {
            String operator = currentPosition().getToken();
            position++;
            BigDecimal right = (BigDecimal) arithmeticExpression();
            return evaluateComparison(left, right, operator);
        }
        return left;
    }

    /**
     * Checks if the given token is a comparison operator.
     *
     * @param token The token to check.
     * @return True if the token is a comparison operator, otherwise false.
     */
    private boolean isComparisonOperator(String token) {
        return token.equals(Token.EQUAL_EQUAL) ||
                token.equals(Token.NOT_EQUAL) ||
                token.equals(Token.LESS_THAN) ||
                token.equals(Token.GREATER_THAN) ||
                token.equals(Token.LESS_THAN_OR_EQUAL) ||
                token.equals(Token.GREATER_THAN_OR_EQUAL);
    }

    /**
     * Evaluates a comparison expression.
     *
     * @param left     The left-hand side operand of the comparison.
     * @param right    The right-hand side operand of the comparison.
     * @param operator The comparison operator.
     * @return The result of the comparison as a BigDecimal (1 for true, 0 for false).
     */
    private BigDecimal evaluateComparison(BigDecimal left, BigDecimal right, String operator) {
        return switch (operator) {
            case Token.EQUAL_EQUAL -> left.compareTo(right) == 0 ? BigDecimal.ONE : BigDecimal.ZERO;
            case Token.NOT_EQUAL -> left.compareTo(right) != 0 ? BigDecimal.ONE : BigDecimal.ZERO;
            case Token.LESS_THAN -> left.compareTo(right) < 0 ? BigDecimal.ONE : BigDecimal.ZERO;
            case Token.GREATER_THAN -> left.compareTo(right) > 0 ? BigDecimal.ONE : BigDecimal.ZERO;
            case Token.LESS_THAN_OR_EQUAL -> left.compareTo(right) <= 0 ? BigDecimal.ONE : BigDecimal.ZERO;
            case Token.GREATER_THAN_OR_EQUAL -> left.compareTo(right) >= 0 ? BigDecimal.ONE : BigDecimal.ZERO;
            default -> BigDecimal.ZERO;
        };
    }

    /**
     * Parses an arithmetic expression (+ or -).
     *
     * @return The result of the arithmetic expression.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private Object arithmeticExpression() throws ParseException {
        Object left = term();

        while (currentPosition().getToken().equals(Token.PLUS) ||
                currentPosition().getToken().equals(Token.MINUS)) {
            String operator = currentPosition().getToken();
            consume(operator);
            Object right = term();
            left = applyOperator(left, operator, right);
        }
        return left;
    }

    /**
     * Parses a term expression (*, /, or %).
     *
     * @return The result of the term expression.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private Object term() throws ParseException {
        Object left = factor();

        while (currentPosition().getToken().equals(Token.ASTERISK) ||
                currentPosition().getToken().equals(Token.SLASH) ||
                currentPosition().getToken().equals(Token.PERCENT)) {
            String operator = currentPosition().getToken();
            consume(operator);
            Object right = factor();
            left = applyOperator(left, operator, right);
        }
        return left;
    }

    /**
     * Parses a factor expression (numbers, variables, parenthesized expressions, function calls).
     *
     * @return The result of the factor expression.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private Object factor() throws ParseException {
        Token current = currentPosition();

        return switch (current.getToken()) {
            case Token.NUMBER_LITERAL -> new BigDecimal(consume(Token.NUMBER_LITERAL).getValue());
            case Token.VARIABLE_LITERAL -> getVariableValue(consume(Token.VARIABLE_LITERAL).getValue());
            case Token.BOOLEAN_LITERAL -> Boolean.parseBoolean(consume(Token.BOOLEAN_LITERAL).getValue());
            case Token.STRING_LITERAL -> {
                String literal = consume(Token.STRING_LITERAL).getValue();
                // Handle method calls on string literals
                if (currentPosition().getToken().equals(Token.DOT)) {
                    consume(Token.DOT);
                    String methodName = consume(Token.IDENTIFIER).getValue();
                    yield handleMethodCall(literal, methodName, new ArrayList<>());
                } else {
                    yield literal;
                }
            }
            case Token.LEFT_PAREN -> {
                consume(Token.LEFT_PAREN);
                Object result = expression();
                consume(Token.RIGHT_PAREN);
                yield result;
            }
            case Token.IDENTIFIER, Token.DOLLAR -> {
                String identifier = consumeVariableName(current);

                if (currentPosition().getToken().equals(Token.LEFT_PAREN)) {
                    yield functionCall(identifier);
                }
                // Handle method calls on objects
                else if (currentPosition().getToken().equals(Token.DOT)) {
                    Object value = getVariableValue(identifier);

                    consume(Token.DOT);
                    String methodName = consume(Token.IDENTIFIER).getValue();
                    yield handleMethodCall(value, methodName, new ArrayList<>());
                }
                // Handle array indexing
                else if (currentPosition().getToken().equals(Token.LEFT_BRACKET)) {
                    List<Integer> indices = new ArrayList<>();
                    while (currentPosition().getToken().equals(Token.LEFT_BRACKET)) {
                        consume(Token.LEFT_BRACKET);
                        indices.add(((BigDecimal) expression()).intValue());
                        consume(Token.RIGHT_BRACKET);
                    }
                    yield getVariableValueAtIndex(identifier, indices);
                } else {
                    for (Map<String, Object> scope : scopes) {
                        if (scope.containsKey(identifier)) {
                            yield scope.get(identifier);
                        }
                    }

                    yield getVariableValue(identifier);
                }
            }
            default -> throw unexpectedTokenException("Unexpected token in factor");
        };
    }

    /**
     * Handles method calls on objects.
     *
     * @param context     The object on which the method is being called (can be null for static methods).
     * @param methodName The name of the method being called.
     * @param args       The list of arguments passed to the method.
     * @return The result of the method call.
     * @throws ParseException If an error occurs during method call resolution or execution.
     */
    private Object handleMethodCall(Object context, String methodName, List<Object> args) throws ParseException {
        if (context == null && args.size() > 0) {
            context = args.remove(0);
        }

        Map<Class<?>, BuiltinFunction> functions = builtinFunctions.get(methodName);
        if (functions == null) {
            throw new ParseException(fileName, "Undefined method: " + methodName,
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }

        BuiltinFunction function = functions.get(context.getClass());
        if (function == null) {
            throw new ParseException(fileName, "Method " + methodName + " is not applicable for " + context.getClass().getSimpleName(),
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }
        return function.execute(context, args);
    }

    /**
     * Applies an arithmetic operator to two operands.
     *
     * @param left     The left-hand side operand.
     * @param operator The operator to apply.
     * @param right    The right-hand side operand.
     * @return The result of the operation.
     * @throws ParseException If the operation is not supported for the given operand types.
     */
    private Object applyOperator(Object left, String operator, Object right) throws ParseException {
        if (left instanceof BigDecimal && right instanceof BigDecimal) {
            return switch (operator) {
                case Token.PLUS -> ((BigDecimal) left).add((BigDecimal) right);
                case Token.MINUS -> ((BigDecimal) left).subtract((BigDecimal) right);
                case Token.ASTERISK -> ((BigDecimal) left).multiply((BigDecimal) right);
                case Token.PERCENT -> ((BigDecimal) left).remainder((BigDecimal) right);
                case Token.SLASH -> {
                    if (((BigDecimal) right).compareTo(BigDecimal.ZERO) == 0) {
                        throw new ParseException(fileName, "Division by zero",
                                currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
                    }
                    yield ((BigDecimal) left).divide((BigDecimal) right, MathContext.DECIMAL128);
                }
                default -> throw new ParseException(fileName, "Unsupported operator: " + operator,
                        currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
            };
        } else if (operator.equals(Token.PLUS) && (left instanceof String || right instanceof String)) {
            return left.toString() + right.toString();
        } else {
            throw new ParseException(fileName, "Invalid operation between types",
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }
    }

    /**
     * Gets the value of a variable at the specified indices in an array (or nested arrays).
     *
     * @param variableName The name of the array variable.
     * @param indices   The list of indices to access the array element.
     * @return The value of the array element.
     * @throws ParseException If the variable is not found, or if an invalid array access is attempted.
     */
    private Object getVariableValueAtIndex(String variableName, List<Integer> indices) throws ParseException {
        Object variable = getVariableValue(variableName);
        return getValueAtIndices(variable, indices, 0);
    }

    /**
     * Recursively gets the value at the specified indices in a potentially nested array.
     *
     * @param array   The current array or element being accessed.
     * @param indices The list of indices to access the element.
     * @param depth   The current depth of recursion in the array.
     * @return The value of the element at the specified indices.
     * @throws ParseException If an invalid array access is attempted (e.g., accessing a non-array element as an array).
     */
    private Object getValueAtIndices(Object array, List<Integer> indices, int depth) throws ParseException {
        if (depth == indices.size()) {
            return array;
        }
        if (array instanceof List<?>) {
            List<?> list = (List<?>) array;
            int index = indices.get(depth);
            if (index < 0 || index >= list.size()) {
                throw new ParseException(fileName, "Array index out of bounds: " + index,
                        currentPosition().getLine(),
                        currentPosition().getColumn(),
                        getCurrentLine());
            }
            return getValueAtIndices(list.get(index), indices, depth + 1);
        } else {
            throw new ParseException(fileName, "Trying to access non-array element as array",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }
    }

    /**
     * Consumes a variable name token, handling both regular variables and constants (prefixed with '$').
     *
     * @param current The current token being processed.
     * @return The variable name.
     * @throws ParseException If an expected identifier token is not found.
     */
    private String consumeVariableName(Token current) throws ParseException {
        if (current.getToken().equals(Token.DOLLAR)) {
            position++;
            return consume(Token.IDENTIFIER).getValue();
        } else {
            position++;
            return current.getValue();
        }
    }

    /**
     * Gets the value of a variable from the current scope or any enclosing scope.
     *
     * @param variableName The name of the variable to retrieve.
     * @return The value of the variable.
     * @throws ParseException If the variable is not found in the current scope or any enclosing scope.
     */
    private Object getVariableValue(String variableName) throws ParseException {
        Iterator<Map<String, Object>> iterator = scopes.descendingIterator();

        while (iterator.hasNext()) {
            Map<String, Object> scope = iterator.next();

            if (scope.containsKey(variableName)) {
                return scope.get(variableName);
            }
        }

        throw new ParseException(fileName, "Undefined variable: " + variableName,
                currentPosition().getLine(),
                currentPosition().getColumn(),
                getCurrentLine());
    }

    /**
     * Checks if a variable with the given name is declared in the current scope or any enclosing scope.
     *
     * @param variableName The name of the variable to check.
     * @return True if the variable is declared, otherwise false.
     */
    private boolean isVariableDeclared(String variableName) {
        for (Map<String, Object> scope : scopes) {
            if (scope.containsKey(variableName)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if a variable with the given name is declared as a constant.
     *
     * @param variableName The name of the variable to check.
     * @return True if the variable is declared as a constant, otherwise false.
     */
    private boolean isConstantDeclared(String variableName) {
        return constants.contains(variableName);
    }

    /**
     * Assigns a value to a variable if it's declared in the current scope or any enclosing scope.
     *
     * @param variableName The name of the variable to assign the value to.
     * @param value        The value to assign.
     * @return True if the variable was found and assigned the value, otherwise false.
     */
    private boolean assignVariableIfDeclared(String variableName, Object value) {
        for (int i = scopes.size() - 1; i >= 0; i--) {
            Map<String, Object> scope = scopes.getLast();
            if (scope.containsKey(variableName)) {
                scope.put(variableName, value);
                return true;
            }
        }
        return false;
    }

    /**
     * Evaluates an expression that should result in a boolean value.
     *
     * @return The boolean result of the expression.
     * @throws ParseException If the expression does not result in a boolean value.
     */
    private boolean evaluateExpression() throws ParseException {
        Object result = expression();
        if (result instanceof Boolean) {
            return (Boolean) result;
        } else {
            throw new ParseException(fileName, "Expected a boolean expression",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }
    }

    /**
     * Evaluates an 'is' expression, checking if a value is of a particular type.
     *
     * @param left  The left-hand side operand (the value being checked).
     * @param type The type to check against.
     * @return True if the value is of the specified type, otherwise false.
     * @throws ParseException If an unsupported type is encountered.
     */
    private boolean evaluateIs(Object left, String type) throws ParseException {
        return switch (type) {
            case Token.NUMBER -> left instanceof BigDecimal;
            case Token.STRING -> left instanceof String;
            case Token.BOOLEAN -> left instanceof Boolean;
            case Token.CHAR -> left instanceof Character;
            case Token.ARRAY -> left instanceof List;
            case Token.NULL -> left == null;
            default -> throw new ParseException(fileName, "Unsupported type: " + type.toLowerCase(),
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        };
    }

    /**
     * Parses a general expression, handling various operators and types.
     *
     * @return The result of the expression.
     * @throws ParseException If a syntax error is encountered during parsing.
     */
    private Object expression() throws ParseException {
        Object left = arithmeticExpression();

        while (isExpressionOperator(currentPosition().getToken()) ||
                currentPosition().getToken().equals(Token.IS)) {

            Token operator = currentPosition();
            consume(operator.getToken());

            if (operator.getToken().equals(Token.IS)) {
                String type = consume(currentPosition().getToken()).getToken();
                left = evaluateIs(left, type);
            } else {
                Object right = arithmeticExpression();
                left = evaluateExpressionOperation(left, right, operator.getToken());
            }
        }
        return left;
    }

    /**
     * Checks if the given token is a valid operator for an expression.
     *
     * @param token The token to check.
     * @return True if the token is a valid expression operator, otherwise false.
     */
    private boolean isExpressionOperator(String token) {
        return token.equals(Token.PLUS) ||
                token.equals(Token.MINUS) ||
                token.equals(Token.EQUAL_EQUAL) ||
                token.equals(Token.NOT_EQUAL) ||
                token.equals(Token.GREATER_THAN) ||
                token.equals(Token.LESS_THAN) ||
                token.equals(Token.GREATER_THAN_OR_EQUAL) ||
                token.equals(Token.LESS_THAN_OR_EQUAL) ||
                token.equals(Token.AND) ||
                token.equals(Token.OR);
    }

    /**
     * Evaluates an operation within an expression, handling different operand types.
     *
     * @param left     The left-hand side operand.
     * @param right    The right-hand side operand.
     * @param operator The operator to apply.
     * @return The result of the operation.
     * @throws ParseException If an invalid operation is attempted for the given operand types.
     */
    private Object evaluateExpressionOperation(Object left, Object right, String operator) throws ParseException {
        if (left instanceof BigDecimal && right instanceof BigDecimal) {
            return evaluateArithmeticOperation((BigDecimal) left, (BigDecimal) right, operator);
        } else if (left instanceof String && right instanceof String) {
            return evaluateStringOperation((String) left, (String) right, operator);
        } else if (left instanceof Boolean && right instanceof Boolean) {
            return evaluateBooleanOperation((Boolean) left, (Boolean) right, operator);
        } else {
            throw new ParseException(fileName, "Invalid operation between types",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }
    }

    /**
     * Evaluates a boolean operation (==, !=, &&, ||) between two boolean operands.
     *
     * @param left     The left-hand side operand.
     * @param right    The right-hand side operand.
     * @param operator The boolean operator.
     * @return The result of the boolean operation.
     * @throws IllegalArgumentException If an unsupported operator is encountered.
     */
    private Object evaluateBooleanOperation(Boolean left, Boolean right, String operator) {
        return switch (operator) {
            case Token.EQUAL_EQUAL -> left == right;
            case Token.NOT_EQUAL -> left != right;
            case Token.AND -> left && right;
            case Token.OR -> left || right;
            default -> throw new IllegalArgumentException("Unsupported operator for boolean: " + operator);
        };
    }

    /**
     * Evaluates an arithmetic or comparison operation between two BigDecimal operands.
     *
     * @param left     The left-hand side operand.
     * @param right    The right-hand side operand.
     * @param operator The operator to apply.
     * @return The result of the operation (either a BigDecimal or a Boolean).
     */
    private Object evaluateArithmeticOperation(BigDecimal left, BigDecimal right, String operator) {
        return switch (operator) {
            case Token.EQUAL_EQUAL -> left.compareTo(right) == 0;
            case Token.NOT_EQUAL -> left.compareTo(right) != 0;
            case Token.GREATER_THAN -> left.compareTo(right) > 0;
            case Token.LESS_THAN -> left.compareTo(right) < 0;
            case Token.GREATER_THAN_OR_EQUAL -> left.compareTo(right) >= 0;
            case Token.LESS_THAN_OR_EQUAL -> left.compareTo(right) <= 0;
            default -> left;
        };
    }

    /**
     * Evaluates an operation between two String operands.
     *
     * @param left     The left-hand side operand.
     * @param right    The right-hand side operand.
     * @param operator The operator to apply.
     * @return The result of the operation.
     */
    private Object evaluateStringOperation(String left, String right, String operator) {
        return switch (operator) {
            case Token.PLUS -> left + right;
            case Token.EQUAL_EQUAL -> left.equals(right);
            case Token.NOT_EQUAL -> !left.equals(right);
            default -> left;
        };
    }

    /**
     * Gets the token at the current position in the token list.
     *
     * @return The current token.
     */
    private Token currentPosition() {
        if (position >= tokens.size()) {
            return new Token(Token.EOF, null, tokens.get(tokens.size() - 1).getLine(), tokens.get(tokens.size() - 1).getColumn());
        }
        return tokens.get(position);
    }

    /**
     * Consumes the current token if it matches the expected token type.
     *
     * @param expectedToken The expected token type.
     * @return The consumed token.
     * @throws ParseException If the current token does not match the expected token type.
     */
    private Token consume(String expectedToken) throws ParseException {
        Token current = currentPosition();
        if (current.getToken().equals(expectedToken)) {
            position++;
            return current;
        } else {
            throw new ParseException(fileName, "Expected '" + expectedToken + "', found '" + current.getToken() + "'",
                    currentPosition().getLine(),
                    currentPosition().getColumn(),
                    getCurrentLine());
        }
    }

    /**
     * Gets the current line of code being parsed.
     *
     * @return The current line of code.
     */
    private String getCurrentLine() {
        return lines[currentPosition().getLine() - 1];
    }

    /**
     * Gets the current scope for variable resolution.
     *
     * @return The current scope as a Map.
     */
    private Map<String, Object> getCurrentScope() {
        return scopes.peek();
    }

    /**
     * Peeks ahead in the token list by the specified offset.
     *
     * @param offset The offset to peek ahead.
     * @return The token at the peeked position.
     */
    private Token peek(int offset) {
        if (position + offset >= tokens.size())
            return new Token(Token.EOF, null, currentPosition().getLine(), currentPosition().getColumn());
        return tokens.get(position + offset);
    }

    /**
     * Throws a ParseException indicating an unexpected token.
     *
     * @param message The error message.
     * @return A new ParseException instance.
     */
    private ParseException unexpectedTokenException(String message) {
        return new ParseException(fileName, message,
                currentPosition().getLine(),
                currentPosition().getColumn(),
                getCurrentLine());
    }

    /**
     * Registers a built-in function with the parser.
     *
     * @param name         The name of the function.
     * @param contextType The type of the context object required for the function (or null if no context is needed).
     * @param function    The function implementation.
     */
    private void registerBuiltinFunction(String name, Class<?> contextType, BuiltinFunction function) {
        builtinFunctions.computeIfAbsent(name, k -> new HashMap<>()).put(contextType, function);
    }

    /**
     * Validates if the given type string is a valid data type in the language.
     *
     * @param type The type string to validate.
     * @throws ParseException If the type is not valid.
     */
    private void validateType(String type) throws ParseException {
        if (!VALID_TYPES.contains(type)) {
            throw new ParseException(fileName, "Invalid parameter type: " + type,
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }
    }

    /**
     * Validates if the given type string is a valid return type for a function.
     *
     * @param returnType The return type string to validate.
     * @throws ParseException If the return type is not valid.
     */
    private void validateReturnType(String returnType) throws ParseException {
        if (!VALID_RETURN_TYPES.contains(returnType)) {
            throw new ParseException(fileName, "Invalid return type: " + returnType,
                    currentPosition().getLine(), currentPosition().getColumn(), getCurrentLine());
        }
    }
}